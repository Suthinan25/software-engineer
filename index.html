<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>เส้นทางสู่ Software Engineer (ดีไซน์ใหม่)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Twilight Indigo -->
    <!-- Application Structure Plan: This version implements a three-level nested accordion structure as requested. Level 1: Main skill groups. Level 2: Subgroups within each main group. Level 3: Individual task items. This provides maximum control over content visibility, allowing the user to drill down from a high-level overview to the most granular details, combined with the preferred aesthetic design. -->
    <!-- Visualization & Content Choices: 
        - Nested Accordion List (Goal: Organize/Inform): The entire application is now a series of nested accordions, creating a hierarchical and fully collapsible information architecture.
        - Animated Background (Goal: Aesthetics): A subtle, slow-moving CSS gradient animation is used for a beautiful, non-distracting background.
        - Playful Animations (Goal: Engagement): The accordion open/close animation is enhanced with a smoother cubic-bezier transition and a subtle opacity fade-in for the content, making the interaction feel more fluid and playful.
        - Icons (Goal: Inform): SVG-like paths are used for the accordion indicators for a sharp, modern look.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Sarabun', sans-serif;
            background-color: #f1f5f9; /* slate-100 */
            color: #334155; /* slate-700 */
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: radial-gradient(circle at 10% 20%, rgba(165, 180, 252, 0.2), transparent 40%),
                        radial-gradient(circle at 80% 70%, rgba(192, 132, 252, 0.2), transparent 40%);
            animation: move-gradient 20s ease-in-out infinite alternate;
        }

        @keyframes move-gradient {
            from {
                transform: translate(0, 0);
            }
            to {
                transform: translate(50px, 50px);
            }
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .accordion-content-inner {
             transition: opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1);
             opacity: 0;
        }

        .accordion-button.open + .accordion-content {
            /* opacity is handled by the inner div for better animation */
        }
        
        .accordion-button.open + .accordion-content .accordion-content-inner {
             opacity: 1;
        }

        .accordion-button svg {
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .accordion-button.open svg {
            transform: rotate(180deg);
        }

        .card {
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        .card:hover {
             box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body>

    <div class="container mx-auto px-4 pt-16 md:pt-24 max-w-4xl">
        <header class="text-center mb-16">
            <h1 class="text-4xl md:text-5xl font-bold text-slate-900 mb-4">เส้นทางสู่ Software Engineer มืออาชีพ</h1>
            <p class="text-lg md:text-xl text-slate-600">คู่มือทักษะสำคัญสำหรับนักพัฒนาซอฟต์แวร์</p>
        </header>

        <main class="space-y-5" id="skill-groups-container">
            <!-- Skill groups will be injected here by JS -->
        </main>
    </div>

    <script>
        const skillData = [
            {
                group: "กลุ่มที่ 1: รากฐานการออกแบบและเขียนโค้ด",
                id: "group1",
                intro: "หมวดหมู่นี้คือหัวใจของการสร้างซอฟต์แวร์ที่มีคุณภาพ ครอบคลุมถึงหลักการและรูปแบบการออกแบบที่ผ่านการพิสูจน์แล้วว่าช่วยให้โค้ดมีความยืดหยุ่น บำรุงรักษา และขยายระบบได้ง่ายในระยะยาว",
                subgroups: [
                    {
                        title: "1. Design Patterns (รูปแบบการออกแบบ)",
                        detailedIntro: "Design Patterns คือพิมพ์เขียวหรือต้นแบบการแก้ปัญหาที่นักพัฒนาซอฟต์แวร์ทั่วโลกยอมรับและใช้กันอย่างแพร่หลาย มันไม่ใช่โค้ดสำเร็จรูป แต่เป็นแนวคิดที่ช่วยให้เราจัดโครงสร้างโค้ดได้อย่างมีประสิทธิภาพ การรู้จัก Patterns ทำให้เราสามารถนำวิธีแก้ปัญหาที่เคยได้ผลดีมาแล้วมาปรับใช้กับโปรเจกต์ของเราได้ทันที ช่วยลดเวลาในการออกแบบและทำให้โค้ดที่ได้มีความยืดหยุ่นสูง ง่ายต่อการบำรุงรักษาและต่อยอดในอนาคต เหมือนกับการมีตำราทำอาหารชั้นดีที่ช่วยให้เราปรุงเมนูที่ซับซ้อนได้อย่างมั่นใจ",
                        tasks: [
                            { title: "ศึกษารูปแบบการสร้าง Object (Creational): Singleton, Factory, Builder", description: "Creational Patterns เป็นกลุ่มของรูปแบบการออกแบบที่เน้นเรื่อง 'การสร้างอ็อบเจกต์' อย่างชาญฉลาด แทนที่จะสร้างอ็อบเจกต์ตรงๆ ด้วยคีย์เวิร์ด `new` ซึ่งอาจทำให้โค้ดผูกมัดและแก้ไขยาก รูปแบบเหล่านี้จะมอบกลไกที่ยืดหยุ่นกว่า เช่น Singleton ที่รับประกันว่าทั้งระบบจะมีอ็อบเจกต์นั้นเพียงชิ้นเดียว เหมาะสำหรับจัดการทรัพยากรส่วนกลาง หรือ Factory Method ที่มอบหมายหน้าที่การสร้างอ็อบเจกต์ให้คลาสลูกเป็นผู้ตัดสินใจ ทำให้เพิ่มประเภทของผลิตภัณฑ์ใหม่ๆ ได้โดยไม่ต้องแก้โค้ดเดิม การเข้าใจรูปแบบเหล่านี้คือการเรียนรู้วิธีสร้างรากฐานที่มั่นคงและขยายได้ง่ายให้กับซอฟต์แวร์ของคุณ" },
                            { title: "ศึกษารูปแบบโครงสร้าง (Structural): Adapter, Decorator, Facade", description: "Structural Patterns คือกลุ่มของรูปแบบที่ว่าด้วยการ 'จัดองค์ประกอบ' ของคลาสและอ็อบเจกต์เพื่อสร้างโครงสร้างที่ใหญ่และซับซ้อนขึ้นอย่างมีระเบียบ มันช่วยให้เราสามารถรวมส่วนประกอบที่ไม่เข้ากันให้ทำงานร่วมกันได้ เช่น Adapter ที่เป็นเหมือนปลั๊กแปลงไฟ หรือเพิ่มความสามารถใหม่ๆ ให้กับอ็อบเจกต์ที่มีอยู่แล้วโดยไม่ต้องไปยุ่งกับโค้ดเดิมด้วย Decorator นอกจากนี้ยังช่วยสร้าง Interface ที่เรียบง่ายเพื่อปิดบังความซับซ้อนของระบบเบื้องหลังด้วย Facade ทำให้โค้ดโดยรวมดูสะอาดและใช้งานง่ายขึ้น" },
                            { title: "ศึกษารูปแบบพฤติกรรม (Behavioral): Observer, Strategy, Command", description: "Behavioral Patterns เน้นไปที่ 'การสื่อสารและการทำงานร่วมกัน' ระหว่างอ็อบเจกต์ต่างๆ ในระบบ มันช่วยกำหนดว่าอ็อบเจกต์ควรจะโต้ตอบกันอย่างไรเพื่อให้ระบบมีความยืดหยุ่นและลดการพึ่งพากันโดยตรง ตัวอย่างเช่น Observer Pattern ที่ทำให้อ็อบเจกต์หนึ่งสามารถส่งข่าวสารอัปเดตไปยังอ็อบเจกต์อื่นๆ ที่สนใจได้โดยอัตโนมัติ หรือ Strategy Pattern ที่ทำให้เราสามารถสลับอัลกอริทึมหรือวิธีการทำงานไปมาได้อย่างอิสระ การใช้รูปแบบเหล่านี้ช่วยให้โค้ดของเราพร้อมรับมือกับการเปลี่ยนแปลงได้ดีขึ้น" },
                            { title: "ลองนำ Design Pattern อย่างน้อย 3 แบบไปปรับใช้ในโปรเจกต์ส่วนตัว", description: "ทฤษฎีจะสมบูรณ์ได้ก็ต่อเมื่อมีการลงมือปฏิบัติจริง การเลือก Design Pattern ที่คุณคิดว่าน่าสนใจหรือเกี่ยวข้องกับปัญหาที่เคยเจอมาลองปรับใช้ในโปรเจกต์เล็กๆ ของตัวเอง จะเป็นวิธีที่ดีที่สุดในการทำความเข้าใจอย่างถ่องแท้ คุณจะได้เห็นว่ามันช่วยแก้ปัญหาได้อย่างไร มีข้อดีอย่างไร และอาจมีข้อจำกัดอะไรบ้างในสถานการณ์จริง ประสบการณ์ตรงนี้มีค่ามากกว่าการอ่านทฤษฎีเพียงอย่างเดียว และจะทำให้คุณเลือกใช้เครื่องมือเหล่านี้ได้อย่างมั่นใจในอนาคต" }
                        ]
                    },
                    {
                        title: "2. Design Principles (หลักการออกแบบ)",
                        detailedIntro: "Design Principles เป็นเหมือนเข็มทิศหรือปรัชญาในการเขียนโค้ดที่ดี หลักการเหล่านี้ (เช่น SOLID, KISS, DRY) ไม่ได้บอกวิธีการเขียนโค้ดแบบเจาะจง แต่ให้แนวทางกว้างๆ เพื่อชี้นำการตัดสินใจในการออกแบบ การยึดมั่นในหลักการเหล่านี้จะช่วยให้เราสร้างซอฟต์แวร์ที่เข้าใจง่าย มีความซับซ้อนน้อยที่สุด และลดการเขียนโค้ดซ้ำซ้อน ซึ่งส่งผลโดยตรงต่อคุณภาพของซอฟต์แวร์ในระยะยาว ทำให้ง่ายต่อการแก้ไข, ทดสอบ, และทำงานร่วมกับผู้อื่นในทีม",
                        tasks: [
                            { title: "ทำความเข้าใจหลักการ SOLID ทั้ง 5 ข้อ พร้อมยกตัวอย่างโค้ดได้", description: "SOLID คือชุดของหลักการ 5 ข้อที่เป็นหัวใจของการออกแบบซอฟต์แวร์เชิงอ็อบเจกต์ให้ดีและยั่งยืน (Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion) แต่ละหลักการจะช่วยชี้นำให้เราสร้างโค้ดที่สามารถทนทานต่อการเปลี่ยนแปลงได้ดี ลดผลกระทบเมื่อมีการแก้ไข และง่ายต่อการนำกลับมาใช้ใหม่ การเข้าใจและนำ SOLID ไปใช้จะยกระดับคุณภาพโค้ดของคุณให้เป็นมืออาชีพมากขึ้นอย่างเห็นได้ชัด" },
                            { title: "ฝึก Refactor โค้ดที่ซ้ำซ้อนตามหลัก DRY (Don't Repeat Yourself)", description: "หลักการ 'อย่าทำซ้ำตัวเอง' หรือ DRY เป็นหนึ่งในหลักการพื้นฐานที่สุดแต่ทรงพลังมาก มันสอนให้เรามองหา Logic หรือโค้ดส่วนที่ทำงานเหมือนกันในหลายๆ ที่ แล้วสกัดมันออกมาเป็นฟังก์ชันหรือคลาสที่สามารถเรียกใช้ซ้ำได้ การทำเช่นนี้ไม่เพียงแต่ทำให้โค้ดสั้นลง แต่ยังช่วยลดโอกาสเกิดความผิดพลาดได้อย่างมหาศาล เพราะเมื่อต้องการแก้ไข Logic นั้น เราก็สามารถแก้ได้จากที่เดียว ไม่ต้องตามไปแก้ทุกที่ที่เคยคัดลอกไปวางไว้" },
                            { title: "ประเมินโปรเจกต์ของตัวเองว่ามีส่วนไหนที่ทำเกินความจำเป็น (YAGNI)", description: "YAGNI หรือ 'You Ain't Gonna Need It' เป็นหลักการที่ช่วยป้องกันการทำงานที่ไม่จำเป็น มันคือการเตือนสติให้นักพัฒนาสร้างเฉพาะฟังก์ชันหรือความสามารถที่จำเป็นสำหรับความต้องการในปัจจุบันเท่านั้น เรามักจะคิดไปล่วงหน้าว่า 'อนาคตอาจจะได้ใช้' แล้วสร้างสิ่งที่ซับซ้อนเกินจำเป็น ซึ่งสุดท้ายแล้วอาจจะไม่ได้ใช้เลย การยึดหลัก YAGNI ช่วยให้เรามุ่งเน้นไปที่การส่งมอบคุณค่าที่แท้จริงในปัจจุบัน และทำให้โปรเจกต์ไม่บวมหรือซับซ้อนเกินไป" },
                            { title: "พยายามเขียนโค้ดแต่ละส่วนให้เรียบง่ายและตรงไปตรงมาที่สุด (KISS)", description: "KISS หรือ 'Keep It Simple, Stupid' เป็นปรัชญาที่ว่าด้วยการออกแบบและแก้ปัญหาด้วยวิธีที่เรียบง่ายที่สุดเท่าที่จะเป็นไปได้ บ่อยครั้งที่วิธีแก้ปัญหาที่ตรงไปตรงมาและไม่ซับซ้อนกลับเป็นวิธีที่ดีที่สุดในระยะยาว เพราะโค้ดที่เรียบง่ายจะง่ายต่อการอ่าน, ทำความเข้าใจ, ทดสอบ, และแก้ไขโดยเพื่อนร่วมทีมคนอื่นๆ ในอนาคต ก่อนที่จะเลือกใช้วิธีที่ซับซ้อนหรือเทคนิคขั้นสูง ให้ถามตัวเองเสมอว่า 'มีวิธีที่ง่ายกว่านี้ไหม?'" }
                        ]
                    }
                ]
            },
            {
                group: "กลุ่มที่ 2: กระบวนการและเครื่องมือ",
                id: "group2",
                intro: "การเขียนโค้ดเป็นเพียงส่วนหนึ่งของการพัฒนาซอฟต์แวร์ หมวดหมู่นี้จะเน้นไปที่กระบวนการและเครื่องมือที่ช่วยให้การทำงานร่วมกับทีมมีประสิทธิภาพ ทำให้มั่นใจได้ว่าซอฟต์แวร์ที่ส่งมอบมีคุณภาพสูงและเชื่อถือได้",
                subgroups: [
                    {
                        title: "3. Good Engineering Practices (แนวปฏิบัติทางวิศวกรรมที่ดี)",
                        detailedIntro: "แนวปฏิบัติทางวิศวกรรมที่ดีคือชุดของกระบวนการที่ช่วยรับประกันคุณภาพของซอฟต์แวร์ การทดสอบ (Testing) ช่วยให้เรามั่นใจว่าโค้ดทำงานถูกต้องตามที่คาดหวัง CI/CD เป็นระบบอัตโนมัติที่ช่วยรวมโค้ดและนำไปใช้งานได้อย่างรวดเร็วและต่อเนื่อง ลดความผิดพลาดจากคน ส่วนการ Refactoring คือการปรับปรุงโครงสร้างโค้ดให้ดีขึ้นอยู่เสมอโดยไม่กระทบการทำงานภายนอก ทั้งหมดนี้รวมกันเป็นวินัยที่ช่วยให้ทีมส่งมอบงานที่มีคุณภาพสูงและน่าเชื่อถือ",
                        tasks: [
                            { title: "เขียน Unit Test สำหรับฟังก์ชันที่สำคัญในโปรเจกต์", description: "Unit Test คือการสร้างโค้ดเพื่อทดสอบโค้ดส่วนที่เล็กที่สุด (เช่น ฟังก์ชันเดียว) โดยเฉพาะ เพื่อให้แน่ใจว่ามันทำงานได้ถูกต้องตามลำพัง การมี Unit Test ที่ดีเปรียบเสมือนตาข่ายนิรภัยที่ช่วยให้เรากล้าที่จะแก้ไขหรือเพิ่มฟีเจอร์ใหม่ๆ ได้อย่างมั่นใจ เพราะถ้าหากการเปลี่ยนแปลงของเราไปทำให้ส่วนอื่นพัง Unit Test จะฟ้องเราทันที มันคือการลงทุนเพื่อคุณภาพและความน่าเชื่อถือของซอฟต์แวร์ในระยะยาว" },
                            { title: "ตั้งค่า CI/CD Pipeline พื้นฐานสำหรับโปรเจกต์ (เช่น ใช้ GitHub Actions)", description: "CI/CD คือกระบวนการอัตโนมัติที่เริ่มต้นตั้งแต่การรวมโค้ดของทุกคนในทีม (Continuous Integration) ไปจนถึงการทดสอบและนำซอฟต์แวร์ไปติดตั้งบนเซิร์ฟเวอร์ (Continuous Deployment) การตั้งค่า Pipeline อัตโนมัตินี้ช่วยลดความผิดพลาดที่เกิดจากการทำงานด้วยมือ ทำให้ทีมสามารถส่งมอบฟีเจอร์ใหม่ๆ ให้ผู้ใช้ได้บ่อยและรวดเร็วยิ่งขึ้น เป็นหัวใจสำคัญของการพัฒนาซอฟต์แวร์แบบ Agile ในปัจจุบัน" },
                            { title: "ฝึกทำ Refactoring โค้ดที่ทำงานได้แล้วให้ดีขึ้น", description: "Refactoring คือกระบวนการปรับปรุงโครงสร้างภายในของโค้ด โดยไม่เปลี่ยนแปลงการทำงานภายนอกที่ผู้ใช้เห็น มันคือการ 'ทำความสะอาด' โค้ดที่อาจจะเขียนอย่างเร่งรีบหรือเริ่มจะซับซ้อนเกินไป ให้กลับมาอ่านง่ายและบำรุงรักษาได้สะดวกขึ้น การทำ Refactoring อย่างสม่ำเสมอเปรียบเสมือนการจ่าย 'หนี้ทางเทคนิค' (Technical Debt) ทีละน้อยๆ เพื่อไม่ให้มันพอกพูนจนกลายเป็นปัญหาใหญ่ในอนาคต" }
                        ]
                    },
                    {
                        title: "4. Version Control Systems (ระบบควบคุมเวอร์ชัน)",
                        detailedIntro: "ระบบควบคุมเวอร์ชัน (Version Control) โดยเฉพาะ Git เป็นเครื่องมือที่ขาดไม่ได้สำหรับการทำงานเป็นทีม มันเปรียบเสมือนเครื่องไทม์แมชชีนที่ช่วยให้เราย้อนกลับไปดูการเปลี่ยนแปลงของโค้ดในแต่ละช่วงเวลาได้ ทำให้สามารถติดตามได้ว่าใครแก้ไขอะไร เมื่อไหร่ และทำไม การทำงานกับ Branch ช่วยให้เราสามารถพัฒนาฟีเจอร์ใหม่ๆ หรือทดลองไอเดียได้อย่างปลอดภัยโดยไม่กระทบกับโค้ดหลักของโปรเจกต์ การเข้าใจ Git จึงเป็นพื้นฐานสำคัญที่ทำให้การทำงานร่วมกันราบรื่นและเป็นระบบ",
                        tasks: [
                            { title: "ใช้ `git` คำสั่งพื้นฐานได้คล่อง (commit, push, pull, status)", description: "คำสั่งเหล่านี้เป็นเหมือนการหายใจเข้าออกของการใช้ Git `commit` คือการบันทึกการเปลี่ยนแปลง, `push` คือการส่งการเปลี่ยนแปลงของเราขึ้นไปบนเซิร์ฟเวอร์กลาง, `pull` คือการดึงการเปลี่ยนแปลงของคนอื่นลงมา, และ `status` คือการตรวจสอบสถานะปัจจุบัน การใช้คำสั่งพื้นฐานเหล่านี้ได้อย่างคล่องแคล่วคือจุดเริ่มต้นของการทำงานร่วมกับทีมอย่างมีประสิทธิภาพ" },
                            { title: "ทำงานกับ Branch ได้ (create, checkout, merge)", description: "Branching คือความสามารถที่ทรงพลังที่สุดของ Git มันช่วยให้เราสามารถสร้าง 'กิ่ง' ของโค้ดออกมาเพื่อพัฒนาฟีเจอร์ใหม่หรือแก้ไขบั๊กได้อย่างอิสระ เมื่อทำเสร็จแล้วจึงค่อย 'merge' หรือรวมกลับเข้าไปที่กิ่งหลัก ทำให้โค้ดหลักมีความเสถียรอยู่เสมอ และหลายคนสามารถทำงานขนานกันไปได้โดยไม่รบกวนกัน การเข้าใจและใช้ Branch อย่างถูกต้องจะช่วยให้การพัฒนาโปรเจกต์เป็นไปอย่างราบรื่น" },
                            { title: "สามารถแก้ไขปัญหา Merge Conflict ได้", description: "Merge Conflict คือสถานการณ์ที่หลีกเลี่ยงไม่ได้เมื่อทำงานเป็นทีม มันเกิดขึ้นเมื่อคนสองคนแก้ไขโค้ดในบรรทัดเดียวกันบน Branch ที่ต่างกัน แล้ว Git ไม่สามารถตัดสินใจได้ว่าจะเลือกการเปลี่ยนแปลงของใคร การเรียนรู้วิธีดูว่า Conflict เกิดขึ้นที่ไหนและจะแก้ไขมันอย่างไรด้วยตนเองจึงเป็นทักษะที่จำเป็นอย่างยิ่ง มันแสดงให้เห็นถึงความเข้าใจในการทำงานของ Git และความสามารถในการแก้ปัญหาเฉพาะหน้า" },
                            { title: "เรียนรู้ `git rebase` และเข้าใจความแตกต่างเมื่อเทียบกับ `merge`", description: "`merge` และ `rebase` คือสองวิธีหลักในการรวมโค้ดจาก Branch หนึ่งไปยังอีก Branch หนึ่ง `merge` จะสร้าง commit ใหม่เพื่อบันทึกประวัติการรวม ในขณะที่ `rebase` จะย้ายประวัติของ Branch เราไปต่อท้ายของ Branch ปลายทาง ทำให้ประวัติ (Git History) ดูเป็นเส้นตรงและสะอาดตามากขึ้น การรู้ว่าสถานการณ์ไหนควรใช้อะไรเป็นเครื่องหมายของนักพัฒนาที่มีความเข้าใจใน Git อย่างลึกซึ้ง" },
                            { title: "ศึกษา Workflow การทำงานร่วมกัน เช่น GitFlow หรือ GitHub Flow", description: "Git Workflow คือชุดของกฎและข้อตกลงร่วมกันในทีมว่าจะใช้ Git ในการพัฒนาโปรเจกต์อย่างไร เพื่อให้ทุกคนทำงานไปในทิศทางเดียวกัน การศึกษา Workflow ที่เป็นที่นิยมอย่าง GitFlow (เหมาะกับโปรเจกต์ที่มีการออกเวอร์ชันชัดเจน) หรือ GitHub Flow (เหมาะกับโปรเจกต์ที่ deploy บ่อยๆ) จะช่วยให้คุณเข้าใจกระบวนการทำงานที่เป็นมาตรฐาน และสามารถปรับตัวเข้ากับทีมใหม่ๆ ได้อย่างรวดเร็ว" }
                        ]
                    },
                    {
                        title: "5. Algorithms and Data Structures (อัลกอริทึมและโครงสร้างข้อมูล)",
                        detailedIntro: "อัลกอริทึมและโครงสร้างข้อมูลคือหัวใจของการเขียนโปรแกรมที่มีประสิทธิภาพ โครงสร้างข้อมูล (Data Structures) คือวิธีการจัดเก็บและจัดระเบียบข้อมูล (เช่น Array, Hash Table) เพื่อให้เข้าถึงและจัดการได้ง่าย ส่วนอัลกอริทึม (Algorithms) คือขั้นตอนหรือกระบวนการในการแก้ปัญหา (เช่น การค้นหา, การเรียงลำดับ) การเลือกใช้ทั้งสองอย่างให้เหมาะสมกับปัญหาจะส่งผลอย่างมหาศาลต่อความเร็วและประสิทธิภาพของโปรแกรม โดยเฉพาะเมื่อต้องจัดการกับข้อมูลจำนวนมาก",
                        tasks: [
                            { title: "อธิบาย Big O Notation และวิเคราะห์ความซับซ้อนของโค้ดง่ายๆ ได้", description: "Big O Notation คือมาตรฐานที่ใช้วัด 'ความซับซ้อน' หรือประสิทธิภาพของอัลกอริทึม มันไม่ได้บอกความเร็วเป็นวินาที แต่บอกแนวโน้มว่าอัลกอริทึมจะทำงานช้าลงแค่ไหนเมื่อปริมาณข้อมูลเพิ่มขึ้น (เช่น O(n) หมายถึงช้าลงตามจำนวนข้อมูล, O(1) หมายถึงเร็วคงที่) การเข้าใจ Big O ช่วยให้เราสามารถเปรียบเทียบและเลือกอัลกอริทึมที่เหมาะสมที่สุดสำหรับงานนั้นๆ เพื่อไม่ให้โปรแกรมช้าจนใช้งานไม่ได้เมื่อข้อมูลมีขนาดใหญ่ขึ้น" },
                            { title: "สามารถ Implement Data Structures พื้นฐานได้: Linked List, Stack, Queue, Hash Table", description: "การเรียนรู้ทฤษฎีเพียงอย่างเดียวอาจไม่เพียงพอ การได้ลองลงมือสร้างโครงสร้างข้อมูลพื้นฐานเหล่านี้ด้วยตัวเอง จะทำให้คุณเข้าใจการทำงานภายในอย่างลึกซึ้ง เช่น Linked List จัดการหน่วยความจำอย่างไร, Hash Table แก้ปัญหาการชนกันของข้อมูล (Collision) ได้อย่างไร ประสบการณ์นี้จะทำให้คุณสามารถเลือกใช้โครงสร้างข้อมูลได้อย่างถูกต้องและมั่นใจ และเป็นพื้นฐานที่แข็งแกร่งสำหรับการเรียนรู้โครงสร้างข้อมูลที่ซับซ้อนยิ่งขึ้นต่อไป" },
                            { title: "เข้าใจและ Implement อัลกอริทึมพื้นฐานได้: Binary Search, Sorting Algorithms", description: "การค้นหาและเรียงลำดับข้อมูลเป็นสองปัญหาคลาสสิกที่พบได้บ่อยในการพัฒนาซอฟต์แวร์ การเข้าใจอัลกอริทึมพื้นฐาน เช่น Binary Search ที่สามารถค้นหาข้อมูลในชุดข้อมูลที่เรียงแล้วได้อย่างรวดเร็ว หรืออัลกอริทึมการเรียงลำดับอย่าง Merge Sort และ Quick Sort จะทำให้คุณมีเครื่องมือที่ทรงพลังในการจัดการข้อมูล การสามารถเขียนอัลกอริทึมเหล่านี้ได้ด้วยตัวเองแสดงให้เห็นถึงความเข้าใจในหลักการทำงานอย่างแท้จริง" },
                            { title: "ฝึกแก้โจทย์บนแพลตฟอร์มอย่าง LeetCode, HackerRank หรือ Codewars", description: "วิธีที่ดีที่สุดในการลับคมทักษะด้านอัลกอริทึมและโครงสร้างข้อมูลคือการฝึกฝนแก้ปัญหาอย่างสม่ำเสมอ แพลตฟอร์มเหล่านี้ได้รวบรวมโจทย์ปัญหาจากง่ายไปจนถึงระดับที่ใช้ในการแข่งขันหรือสัมภาษณ์งานในบริษัทเทคโนโลยีชั้นนำ การฝึกแก้โจทย์จะช่วยให้คุณคุ้นเคยกับรูปแบบปัญหาต่างๆ เรียนรู้วิธีการมองปัญหาอย่างเป็นระบบ และฝึกการเขียนโค้ดที่ถูกต้องและมีประสิทธิภาพภายใต้ข้อจำกัด" }
                        ]
                    }
                ]
            },
            {
                group: "กลุ่มที่ 3: สถาปัตยกรรมและระบบ",
                id: "group3",
                intro: "เมื่อซอฟต์แวร์มีความซับซ้อนขึ้น การมองภาพใหญ่และการออกแบบสถาปัตยกรรมที่เหมาะสมคือสิ่งสำคัญ หมวดหมู่นี้จะครอบคลุมตั้งแต่ฐานข้อมูลไปจนถึงการออกแบบระบบขนาดใหญ่ที่รองรับผู้ใช้จำนวนมากได้",
                subgroups: [
                    {
                        title: "6. Databases and SQL (ฐานข้อมูลและภาษา SQL)",
                        detailedIntro: "ฐานข้อมูลเป็นระบบสำหรับจัดเก็บและจัดการข้อมูลของแอปพลิเคชันอย่างเป็นระเบียบ การเข้าใจฐานข้อมูลทั้งแบบ SQL (มีโครงสร้างเป็นตารางชัดเจน) และ NoSQL (มีความยืดหยุ่นสูง) เป็นสิ่งจำเป็น ทักษะสำคัญคือการออกแบบ Schema หรือโครงสร้างการเก็บข้อมูลให้มีประสิทธิภาพ เพื่อลดความซ้ำซ้อนและง่ายต่อการขยายระบบ รวมถึงการเขียนคำสั่ง Query เพื่อดึงข้อมูลออกมาใช้งานได้อย่างรวดเร็ว การมีความรู้เรื่องนี้จะช่วยให้แอปพลิเคชันทำงานกับข้อมูลได้อย่างเต็มประสิทธิภาพ",
                        tasks: [
                            { title: "ออกแบบ Schema ของฐานข้อมูลสำหรับแอปพลิเคชันง่ายๆ ได้", description: "Schema คือพิมพ์เขียวของฐานข้อมูลที่กำหนดว่าเราจะเก็บข้อมูลอะไรบ้าง มีความสัมพันธ์กันอย่างไร การออกแบบ Schema ที่ดีตั้งแต่เริ่มต้นมีความสำคัญอย่างยิ่ง เพราะมันจะช่วยลดความซ้ำซ้อนของข้อมูล ทำให้การดึงข้อมูลมีประสิทธิภาพ และง่ายต่อการปรับเปลี่ยนหรือเพิ่มเติมในอนาคต การออกแบบที่ไม่ดีอาจนำไปสู่ปัญหาด้านประสิทธิภาพและค่าใช้จ่ายในการบำรุงรักษาที่สูงมากในระยะยาว" },
                            { title: "เขียนคำสั่ง SQL ที่ซับซ้อนขึ้นได้ (เช่น JOIN หลายตาราง, Subquery)", description: "ข้อมูลในโลกจริงมักจะไม่ได้เก็บอยู่ในตารางเดียว แต่กระจายอยู่ในหลายๆ ตารางที่มีความสัมพันธ์กัน การเขียนคำสั่ง `JOIN` เพื่อรวมข้อมูลจากหลายตาราง หรือการใช้ `Subquery` (คำสั่งซ้อนคำสั่ง) เพื่อกรองข้อมูลที่ซับซ้อน จึงเป็นทักษะที่จำเป็นอย่างยิ่งในการดึงข้อมูลที่ต้องการออกมาได้อย่างถูกต้องและครบถ้วน มันคือเครื่องมือที่ทำให้เราสามารถถามคำถามที่ซับซ้อนกับฐานข้อมูลของเราได้" },
                            { title: "เข้าใจความสำคัญของ Index และสามารถสร้างเพื่อเพิ่มประสิทธิภาพ Query ได้", description: "Index ในฐานข้อมูลทำงานคล้ายกับดัชนีท้ายเล่มหนังสือ มันช่วยให้ระบบสามารถค้นหาข้อมูลที่ต้องการได้อย่างรวดเร็วโดยไม่ต้องไล่ดูทีละแถว การสร้าง Index ในคอลัมน์ที่ถูกใช้ในการค้นหาหรือ `JOIN` บ่อยๆ สามารถเพิ่มความเร็วในการ Query ได้เป็นสิบหรือร้อยเท่า การรู้ว่าควรจะสร้าง Index ที่ไหนและอย่างไรจึงเป็นทักษะสำคัญของนักพัฒนาที่ต้องทำงานกับข้อมูลจำนวนมาก" },
                            { title: "อธิบายความแตกต่างระหว่างฐานข้อมูล SQL และ NoSQL ได้", description: "SQL (เช่น MySQL, PostgreSQL) เป็นฐานข้อมูลเชิงสัมพันธ์ที่มีโครงสร้างเป็นตารางชัดเจน เหมาะกับข้อมูลที่มีรูปแบบตายตัวและต้องการความถูกต้องสูง ในขณะที่ NoSQL (เช่น MongoDB, Redis) มีความยืดหยุ่นสูงกว่า เหมาะกับข้อมูลที่ไม่มีโครงสร้างแน่นอนหรือต้องการขยายระบบเพื่อรองรับข้อมูลจำนวนมหาศาล การเข้าใจจุดแข็งและจุดอ่อนของแต่ละประเภทจะช่วยให้เราสามารถเลือกใช้เครื่องมือที่เหมาะสมกับลักษณะของปัญหาได้" },
                            { title: "ทดลองใช้ NoSQL Database อย่างน้อย 1 ตัว (เช่น MongoDB, Redis)", description: "ทฤษฎีอย่างเดียวไม่เพียงพอ การได้ลองลงมือติดตั้งและใช้งานฐานข้อมูล NoSQL จริงๆ จะทำให้คุณเข้าใจแนวคิดการทำงานของมันได้อย่างรวดเร็ว ลองสร้างโปรเจกต์เล็กๆ ที่ใช้ MongoDB เพื่อเก็บข้อมูลแบบ Document หรือใช้ Redis เพื่อทำ Caching จะช่วยให้คุณเห็นภาพว่ามันแตกต่างจาก SQL อย่างไร และจะนำไปประยุกต์ใช้ในสถานการณ์จริงได้อย่างไร ประสบการณ์นี้เป็นที่ต้องการอย่างมากในตลาดงานปัจจุบัน" }
                        ]
                    },
                    {
                        title: "7. Software Architecture (สถาปัตยกรรมซอฟต์แวร์)",
                        detailedIntro: "สถาปัตยกรรมซอฟต์แวร์คือการออกแบบโครงสร้างภาพรวมของทั้งระบบ เปรียบเสมือนการวาดพิมพ์เขียวของบ้านก่อนที่จะเริ่มสร้างจริง การตัดสินใจในระดับนี้จะส่งผลต่อทุกส่วนของโปรเจกต์ เช่น การเลือกว่าจะสร้างเป็นแอปพลิเคชันก้อนเดียว (Monolith) หรือจะแบ่งเป็นบริการย่อยๆ (Microservices) การเข้าใจข้อดีข้อเสียของแต่ละรูปแบบสถาปัตยกรรมจะช่วยให้เราสามารถสร้างระบบที่ตอบโจทย์ทางธุรกิจ สามารถขยายขนาดเพื่อรองรับผู้ใช้ในอนาคต และง่ายต่อการบำรุงรักษา",
                        tasks: [
                            { title: "อธิบายข้อดี-ข้อเสียของ Monolithic Architecture", description: "Monolith คือสถาปัตยกรรมแบบดั้งเดิมที่ทุกส่วนของแอปพลิเคชันถูกสร้างและ deploy รวมกันเป็นก้อนเดียว ข้อดีคือเริ่มต้นง่ายและไม่ซับซ้อน เหมาะสำหรับโปรเจกต์ขนาดเล็ก แต่ข้อเสียคือเมื่อระบบใหญ่ขึ้น การแก้ไขส่วนเล็กๆ อาจต้อง deploy ใหม่ทั้งหมด และเทคโนโลยีจะผูกติดกันไปหมด ทำให้ปรับเปลี่ยนได้ยาก การเข้าใจจุดนี้จะช่วยให้รู้ว่าเมื่อไหร่ที่โปรเจกต์ของเราเติบโตเกินกว่าที่ Monolith จะรับไหว" },
                            { title: "อธิบายแนวคิดและข้อดี-ข้อเสียของ Microservices Architecture", description: "Microservices คือแนวคิดในการแบ่งแอปพลิเคชันขนาดใหญ่ออกเป็นบริการย่อยๆ ที่ทำงานเป็นอิสระต่อกัน แต่ละบริการรับผิดชอบหน้าที่ของตัวเองและสามารถพัฒนาหรือ deploy ได้โดยไม่กระทบส่วนอื่น ข้อดีคือความยืดหยุ่นและการขยายระบบที่ง่าย แต่ก็แลกมาด้วยความซับซ้อนในการจัดการและการสื่อสารระหว่างบริการที่เพิ่มขึ้นอย่างมาก การเข้าใจ Trade-off นี้เป็นสิ่งสำคัญในการตัดสินใจเลือกใช้" },
                            { title: "ศึกษาแนวคิดของ Event-Driven Architecture", description: "สถาปัตยกรรมที่ขับเคลื่อนด้วยอีเวนต์ (Event-Driven) คือรูปแบบที่ส่วนต่างๆ ของระบบสื่อสารกันผ่านการส่ง 'อีเวนต์' หรือข้อความ แทนที่จะเรียกหากันโดยตรง วิธีนี้ช่วยลดการพึ่งพาระหว่างกัน (Decoupling) ได้อย่างมาก ทำให้แต่ละส่วนทำงานได้อย่างอิสระและยืดหยุ่นสูง เหมาะสำหรับระบบที่ซับซ้อนและต้องการการตอบสนองแบบเรียลไทม์ เช่น ระบบ E-commerce หรือแอปพลิเคชัน IoT มันเป็นแนวคิดที่ทรงพลังในการสร้างระบบที่พร้อมรับมือกับการเปลี่ยนแปลง" }
                        ]
                    },
                     {
                        title: "8. Security Best Practices (แนวปฏิบัติที่ดีที่สุดด้านความปลอดภัย)",
                        detailedIntro: "ความปลอดภัยไม่ใช่ฟีเจอร์ที่มาเพิ่มทีหลัง แต่เป็นสิ่งที่ต้องคำนึงถึงในทุกขั้นตอนของการพัฒนา การเขียนโค้ดโดยไม่ระวังอาจเปิดช่องโหว่ให้ผู้ไม่หวังดีเข้ามาโจมตีระบบได้ เช่น การขโมยข้อมูลผู้ใช้ หรือทำให้ระบบล่ม ดังนั้น Software Engineer จึงต้องรู้จักช่องโหว่ที่พบบ่อย (เช่น SQL Injection, XSS) และรู้วิธีการเขียนโค้ดเพื่อป้องกันภัยคุกคามเหล่านั้น การสร้างซอฟต์แวร์ที่ปลอดภัยคือการสร้างความไว้วางใจให้กับผู้ใช้งาน",
                        tasks: [
                            { title: "อ่านและทำความเข้าใจความเสี่ยงใน OWASP Top 10", description: "OWASP (Open Web Application Security Project) คือองค์กรที่ไม่แสวงหาผลกำไรที่ทำงานด้านความปลอดภัยของซอฟต์แวร์ พวกเขาจะจัดอันดับ 10 ช่องโหว่ความปลอดภัยบนเว็บที่ร้ายแรงและพบบ่อยที่สุดเป็นประจำ (OWASP Top 10) การศึกษาและทำความเข้าใจรายการนี้ถือเป็นก้าวแรกและเป็นมาตรฐานที่นักพัฒนาเว็บทุกคนต้องรู้ เพื่อให้ตระหนักถึงความเสี่ยงและสามารถป้องกันระบบของตัวเองได้อย่างถูกต้อง" },
                            { title: "รู้วิธีป้องกัน SQL Injection (เช่น การใช้ Prepared Statements)", description: "SQL Injection คือหนึ่งในการโจมตีที่คลาสสิกและอันตรายที่สุด เกิดขึ้นเมื่อผู้โจมตีสามารถแทรกคำสั่ง SQL ที่ประสงค์ร้ายผ่านช่องรับข้อมูลของผู้ใช้ได้ เพื่อเข้าไปจัดการฐานข้อมูลของเราโดยตรง วิธีป้องกันมาตรฐานคือการใช้ 'Prepared Statements' หรือ 'Parameterized Queries' ซึ่งจะแยกคำสั่งออกจากข้อมูลอย่างชัดเจน ทำให้แฮกเกอร์ไม่สามารถแทรกโค้ดที่เป็นอันตรายเข้ามาได้" },
                            { title: "รู้วิธีป้องกัน Cross-Site Scripting (XSS) (เช่น การทำ Output Encoding)", description: "XSS คือการโจมตีที่ผู้ไม่หวังดีฝังสคริปต์ (โดยมากคือ JavaScript) ที่เป็นอันตรายลงในหน้าเว็บของเรา เมื่อผู้ใช้คนอื่นเปิดหน้าเว็บนั้น สคริปต์ดังกล่าวก็จะทำงานในเบราว์เซอร์ของพวกเขา ซึ่งอาจนำไปสู่การขโมยข้อมูลส่วนตัวได้ วิธีป้องกันหลักคือการทำ 'Output Encoding' หรือการแปลงอักขระพิเศษต่างๆ ให้กลายเป็นข้อความธรรมดาก่อนที่จะแสดงผลบนหน้าเว็บ เพื่อไม่ให้เบราว์เซอร์ตีความมันเป็นโค้ด" },
                            { title: "เข้าใจหลักการเก็บรหัสผ่านที่ปลอดภัย (ใช้ Hashing Algorithm เช่น bcrypt)", description: "การเก็บรหัสผ่านของผู้ใช้เป็นข้อความธรรมดา (Plain Text) ในฐานข้อมูลถือเป็นความผิดพลาดร้ายแรงที่ไม่ควรเกิดขึ้นเด็ดขาด เราต้องทำการ 'Hash' รหัสผ่านก่อนเสมอ ซึ่งเป็นกระบวนการแปลงข้อมูลทางเดียวที่ไม่สามารถย้อนกลับได้ โดยต้องใช้อัลกอริทึมที่ออกแบบมาเพื่อการนี้โดยเฉพาะและมีความแข็งแกร่ง เช่น bcrypt หรือ Argon2 เพื่อให้แม้ว่าฐานข้อมูลจะรั่วไหล แต่รหัสผ่านของผู้ใช้ก็ยังคงปลอดภัย" }
                        ]
                    },
                    {
                        title: "9. System Design Fundamentals (พื้นฐานการออกแบบระบบ)",
                        detailedIntro: "พื้นฐานการออกแบบระบบคือการนำความรู้หลายๆ ด้านมาประกอบกันเพื่อสร้างระบบขนาดใหญ่ที่สามารถรองรับผู้ใช้งานจำนวนมากได้ มันคือการคิดในภาพที่ใหญ่ขึ้นกว่าแค่การเขียนโค้ด โดยต้องพิจารณาถึงส่วนประกอบต่างๆ เช่น Load Balancer สำหรับกระจายการใช้งาน, Caching สำหรับเพิ่มความเร็ว, และ CDN สำหรับส่งข้อมูลให้ผู้ใช้ทั่วโลกได้เร็วขึ้น การเข้าใจหลักการเหล่านี้ทำให้เราสามารถออกแบบระบบที่ทำงานได้อย่างเสถียร มีประสิทธิภาพ และพร้อมที่จะเติบโต",
                        tasks: [
                            { title: "อธิบายได้ว่า Load Balancer, Caching, และ CDN ทำงานอย่างไรและใช้เมื่อไหร่", description: "ส่วนประกอบเหล่านี้คือสามทหารเสือในการสร้างระบบให้ 'Scalable' หรือรองรับผู้ใช้จำนวนมากได้ Load Balancer ทำหน้าที่เป็นเหมือนตำรวจจราจร คอยกระจาย request ไปยังเซิร์ฟเวอร์หลายๆ ตัว Caching คือการเก็บข้อมูลที่ใช้บ่อยไว้ในที่ที่เร็วกว่าเพื่อลดภาระฐานข้อมูล ส่วน CDN คือการกระจายไฟล์ (เช่น รูปภาพ, วิดีโอ) ไปไว้ใกล้ผู้ใช้ทั่วโลก การรู้ว่าแต่ละอย่างทำงานอย่างไรและควรใช้เมื่อไหร่เป็นหัวใจของการออกแบบระบบ" },
                            { title: "ศึกษาตัวอย่างการออกแบบระบบขนาดใหญ่ (เช่น Twitter, Netflix, Uber)", description: "วิธีที่ดีที่สุดวิธีหนึ่งในการเรียนรู้การออกแบบระบบคือการศึกษาจากกรณีศึกษาของบริษัทเทคโนโลยีชั้นนำ ลองค้นหาบทความหรือวิดีโอที่อธิบายว่าระบบอย่าง Netflix จัดการการสตรีมวิดีโอให้คนทั่วโลกได้อย่างไร หรือ Uber คำนวณตำแหน่งรถแบบเรียลไทม์ได้อย่างไร การเรียนรู้จากสถาปัตยกรรมของจริงเหล่านี้จะช่วยให้คุณเห็นภาพการนำหลักการต่างๆ มาใช้งานและแก้ปัญหาในสเกลที่ใหญ่มาก" },
                            { title: "ลองออกแบบสถาปัตยกรรมของแอปพลิเคชันง่ายๆ ด้วยตัวเอง (วาดแผนภาพ)", description: "การฝึกฝนที่ดีที่สุดคือการลงมือทำ ลองตั้งโจทย์ง่ายๆ ให้ตัวเอง เช่น 'ถ้าจะสร้าง TinyURL ต้องมีส่วนประกอบอะไรบ้าง?' แล้วลองวาดแผนภาพสถาปัตยกรรมออกมา คิดถึงเรื่องฐานข้อมูล, API, และวิธีที่ส่วนต่างๆ จะสื่อสารกัน การฝึกคิดและออกแบบเช่นนี้บ่อยๆ จะทำให้ทักษะการออกแบบระบบของคุณแข็งแกร่งขึ้นอย่างรวดเร็ว และเป็นทักษะสำคัญที่ใช้ในการสัมภาษณ์งานตำแหน่งระดับสูง" }
                        ]
                    }
                ]
            },
            {
                group: "กลุ่มที่ 4: ความรู้เชิงลึกและรอบด้าน",
                id: "group4",
                intro: "นอกเหนือจากการเขียนโค้ดและออกแบบระบบแล้ว Software Engineer ที่ดีต้องมีความรู้รอบด้าน ตั้งแต่การทำงานของระบบปฏิบัติการ, เครือข่าย, คลาวด์ ไปจนถึงทักษะการสื่อสารและการทำงานร่วมกับผู้อื่น",
                subgroups: [
                    {
                        title: "10. Operating Systems Concepts (ระบบปฏิบัติการ)",
                        detailedIntro: "ระบบปฏิบัติการ (OS) คือซอฟต์แวร์พื้นฐานที่จัดการทรัพยากรทั้งหมดของคอมพิวเตอร์ การเข้าใจว่า OS ทำงานอย่างไร เช่น มันจัดการโปรเซสและหน่วยความจำ (Memory) อย่างไร หรือมันจัดการการทำงานพร้อมๆ กัน (Concurrency) ได้อย่างไร จะช่วยให้เราเขียนโปรแกรมที่ใช้ทรัพยากรได้อย่างมีประสิทธิภาพสูงสุด และสามารถแก้ไขปัญหาที่ซับซ้อนในระดับลึกได้ ความรู้เรื่องนี้เป็นรากฐานที่ทำให้เราเข้าใจว่าโค้ดของเราทำงานบนเครื่องคอมพิวเตอร์จริงๆ ได้อย่างไร",
                        tasks: [
                            { title: "อธิบายความแตกต่างระหว่าง Process และ Thread", description: "Process คือโปรแกรมหนึ่งโปรแกรมที่กำลังทำงานอยู่ในหน่วยความจำ ซึ่งมีพื้นที่ของตัวเองแยกขาดจากโปรแกรมอื่น ในขณะที่ Thread คือหน่วยการทำงานย่อยๆ ที่อยู่ใน Process เดียวกัน สามารถใช้ทรัพยากรร่วมกันได้ การเข้าใจความแตกต่างนี้เป็นพื้นฐานสำคัญในการออกแบบโปรแกรมที่สามารถทำงานหลายๆ อย่างไปพร้อมกันได้ (Concurrent/Parallel Programming) เพื่อใช้ประโยชน์จาก CPU ที่มีหลายคอร์ในปัจจุบัน" },
                            { title: "เข้าใจปัญหาที่เกิดจากการทำงานพร้อมกัน (Concurrency)", description: "เมื่อมีหลาย Thread พยายามเข้าถึงและแก้ไขข้อมูลเดียวกันพร้อมๆ กัน อาจทำให้เกิดปัญหาที่คาดไม่ถึงได้ เช่น Race Condition (ผลลัพธ์ขึ้นอยู่กับว่าใครทำเสร็จก่อน) หรือ Deadlock (ต่างฝ่ายต่างรอทรัพยากรของกันและกันจนไปต่อไม่ได้) การตระหนักถึงปัญหาเหล่านี้และเรียนรู้วิธีป้องกันโดยใช้กลไกอย่าง Mutex หรือ Semaphore เป็นทักษะที่จำเป็นอย่างยิ่งในการสร้างระบบที่ทำงานพร้อมกันได้อย่างถูกต้องและเสถียร" },
                            { title: "อธิบายการจัดการหน่วยความจำเบื้องต้นได้ (Stack vs. Heap)", description: "โปรแกรมของเราใช้หน่วยความจำ (RAM) สองส่วนหลักๆ คือ Stack และ Heap โดย Stack จะใช้เก็บข้อมูลที่มีขนาดแน่นอนและจัดการอย่างรวดเร็ว เช่น ตัวแปร local ในฟังก์ชัน ส่วน Heap จะใช้สำหรับข้อมูลที่มีขนาดไม่แน่นอนหรือต้องการให้มีชีวิตอยู่ต่อไปแม้ฟังก์ชันจะทำงานจบไปแล้ว (Dynamic Memory) การเข้าใจว่าข้อมูลประเภทไหนควรอยู่ที่ไหน จะช่วยให้เราเขียนโปรแกรมที่จัดการหน่วยความจำได้อย่างมีประสิทธิภาพและหลีกเลี่ยงปัญหา Memory Leak ได้" }
                        ]
                    },
                    {
                        title: "11. Networking Fundamentals (พื้นฐานเครือข่าย)",
                        detailedIntro: "ในยุคปัจจุบัน ซอฟต์แวร์ส่วนใหญ่ไม่ได้ทำงานอยู่บนเครื่องเดียว แต่ต้องสื่อสารกันผ่านเครือข่ายคอมพิวเตอร์ ดังนั้นการเข้าใจพื้นฐานด้านเน็ตเวิร์กจึงเป็นสิ่งจำเป็นอย่างยิ่ง เราต้องรู้ว่าข้อมูลถูกส่งจากที่หนึ่งไปยังอีกที่หนึ่งได้อย่างไรผ่านโปรโตคอลอย่าง TCP/IP และ HTTP รวมถึงเข้าใจการทำงานของ APIs ซึ่งเป็นเหมือนภาษากลางที่ทำให้ซอฟต์แวร์ต่างชนิดกันสามารถพูดคุยแลกเปลี่ยนข้อมูลกันได้อย่างราบรื่น",
                        tasks: [
                            { title: "อธิบายหน้าที่ของแต่ละ Layer ใน TCP/IP Model ได้คร่าวๆ", description: "โมเดล TCP/IP เป็นกรอบแนวคิดที่แบ่งกระบวนการสื่อสารผ่านเครือข่ายที่ซับซ้อนออกเป็นชั้น (Layer) ที่จัดการได้ง่ายขึ้น 4-5 ชั้น ตั้งแต่ชั้นกายภาพไปจนถึงชั้นแอปพลิเคชัน การเข้าใจว่าแต่ละชั้นมีหน้าที่อะไร (เช่น Transport Layer (TCP) รับผิดชอบการส่งข้อมูลให้ถึงอย่างน่าเชื่อถือ, Application Layer (HTTP) กำหนดรูปแบบข้อความ) จะช่วยให้เราเห็นภาพรวมของการสื่อสารและสามารถวิเคราะห์ปัญหาที่เกิดขึ้นได้อย่างเป็นระบบ" },
                            { title: "รู้จัก HTTP Methods (GET, POST, PUT, DELETE) และ Status Codes", description: "HTTP คือโปรโตคอลหรือภาษาที่เว็บเบราว์เซอร์และเว็บเซิร์ฟเวอร์ใช้คุยกัน การรู้จักคำสั่งพื้นฐาน (Methods) เช่น `GET` สำหรับการขอข้อมูล, `POST` สำหรับการส่งข้อมูลใหม่, `PUT` สำหรับการอัปเดต และ `DELETE` สำหรับการลบ รวมถึงการเข้าใจความหมายของรหัสสถานะ (Status Codes) เช่น `200 OK`, `404 Not Found`, `500 Internal Server Error` เป็นความรู้ที่ขาดไม่ได้สำหรับนักพัฒนาเว็บทุกคน" },
                            { title: "สามารถออกแบบ RESTful API พื้นฐานได้", description: "API (Application Programming Interface) คือช่องทางที่ทำให้ซอฟต์แวร์สามารถคุยกันได้ และ REST คือรูปแบบสถาปัตยกรรมที่นิยมที่สุดในการออกแบบ API เพราะมีความเรียบง่ายและยืดหยุ่น การออกแบบ RESTful API ที่ดี คือการกำหนด URL และการใช้ HTTP Methods อย่างมีความหมายและสอดคล้องกัน เพื่อให้ API ของเราใช้งานง่ายและเป็นมาตรฐาน เป็นทักษะสำคัญในการสร้างระบบที่ต้องเชื่อมต่อกับบริการอื่นๆ" },
                            { title: "อธิบายขั้นตอนการทำงานของ DNS ได้", description: "DNS (Domain Name System) ทำหน้าที่เหมือนสมุดโทรศัพท์ของอินเทอร์เน็ต มันแปลงชื่อโดเมนที่มนุษย์จำง่าย (เช่น `www.google.com`) ไปเป็น IP Address (เช่น `172.217.16.196`) ที่คอมพิวเตอร์ใช้ในการค้นหาและสื่อสารกันจริงๆ การเข้าใจกระบวนการนี้ ตั้งแต่การถามจากเครื่องตัวเองไปจนถึง Root Server จะช่วยให้เราสามารถวินิจฉัยปัญหาการเชื่อมต่อเว็บไซต์หรือบริการต่างๆ ที่ไม่สามารถเข้าถึงได้" }
                        ]
                    },
                    {
                        title: "12. Cloud Computing & DevOps (คลาวด์และ DevOps)",
                        detailedIntro: "คลาวด์คอมพิวติ้งได้เปลี่ยนวิธีการสร้างและดูแลซอฟต์แวร์ไปอย่างสิ้นเชิง แทนที่จะต้องมีเซิร์ฟเวอร์เป็นของตัวเอง เราสามารถเช่าใช้ทรัพยากรจากผู้ให้บริการอย่าง AWS, GCP, หรือ Azure ได้ตามต้องการ ส่วน DevOps คือวัฒนธรรมและชุดเครื่องมือ (เช่น Docker, Kubernetes) ที่ผสานการพัฒนากับการดำเนินงานเข้าด้วยกัน เพื่อให้สามารถส่งมอบซอฟต์แวร์ใหม่ๆ ให้ผู้ใช้ได้รวดเร็วและเป็นอัตโนมัติมากขึ้น ความรู้ทั้งสองด้านนี้จึงเป็นทักษะสำคัญในโลกการพัฒนาซอฟต์แวร์สมัยใหม่",
                        tasks: [
                            { title: "มีบัญชีผู้ให้บริการคลาวด์ (AWS, GCP, Azure) และเคยลองสร้าง Virtual Machine", description: "วิธีที่ดีที่สุดในการเรียนรู้เรื่องคลาวด์คือการลงมือใช้งานจริง ผู้ให้บริการรายใหญ่ทุกเจ้ามี Free Tier ให้ทดลองใช้บริการพื้นฐานได้ฟรี ลองสมัครบัญชีและทำตามขั้นตอนเพื่อสร้างเซิร์ฟเวอร์เสมือน (Virtual Machine) ของตัวเองขึ้นมา จะทำให้คุณคุ้นเคยกับหน้าจอควบคุม (Dashboard) และแนวคิดพื้นฐานของการจัดการทรัพยากรบนคลาวด์ ซึ่งเป็นก้าวแรกที่สำคัญอย่างยิ่ง" },
                            { title: "ทดลองใช้ Docker เพื่อสร้าง Image สำหรับแอปพลิเคชัน", description: "Docker แก้ปัญหาคลาสสิกที่ว่า 'โค้ดรันบนเครื่องฉันได้ แต่รันบนเครื่องนายไม่ได้' โดยการ 'แพ็ค' แอปพลิเคชันของเราพร้อมกับทุกสิ่งที่มันต้องการ (เช่น library, runtime) ลงในกล่องที่เรียกว่า Image ซึ่งสามารถนำไปรันที่ไหนก็ได้เหมือนกันทุกประการ การเรียนรู้ที่จะสร้าง Dockerfile และ build image สำหรับโปรเจกต์ของคุณ เป็นทักษะพื้นฐานที่นักพัฒนาสมัยใหม่แทบทุกคนต้องมี" },
                            { title: "ลอง Deploy แอปพลิเคชันขึ้นบนบริการคลาวด์", description: "การเขียนโค้ดเสร็จเป็นเพียงครึ่งทาง การนำแอปพลิเคชันนั้นไปติดตั้งบนเซิร์ฟเวอร์เพื่อให้ผู้ใช้ทั่วโลกสามารถเข้าใช้งานได้ (Deployment) คืออีกครึ่งที่สำคัญไม่แพ้กัน ลองนำโปรเจกต์ง่ายๆ ของคุณไป deploy บนบริการคลาวด์ เช่น AWS EC2, Heroku, หรือ Google App Engine จะทำให้คุณได้เรียนรู้กระบวนการทั้งหมด ตั้งแต่การตั้งค่าเซิร์ฟเวอร์ไปจนถึงการจัดการโดเมน" },
                            { title: "ศึกษาว่า Infrastructure as Code (IaC) คืออะไร (เช่น Terraform)", description: "IaC คือแนวคิดในการจัดการและสร้างโครงสร้างพื้นฐาน (Infrastructure) ทั้งหมด เช่น เซิร์ฟเวอร์, เน็ตเวิร์ก, ฐานข้อมูล ผ่านการเขียนโค้ด แทนที่จะต้องเข้าไปคลิกตั้งค่าในหน้าเว็บด้วยมือ เครื่องมืออย่าง Terraform ช่วยให้เราสามารถกำหนดหน้าตาของระบบที่ต้องการเป็นโค้ดได้ ทำให้การสร้างสภาพแวดล้อมใหม่ที่เหมือนกันทุกประการทำได้ง่าย, ทำซ้ำได้, และสามารถตรวจสอบย้อนหลังผ่าน Version Control ได้เหมือนโค้ดทั่วไป" }
                        ]
                    },
                    {
                        title: "13. Software Development Methodologies (ระเบียบวิธีการพัฒนา)",
                        detailedIntro: "ระเบียบวิธีการพัฒนาซอฟต์แวร์คือกรอบการทำงานที่ช่วยให้ทีมพัฒนาทำงานร่วมกันได้อย่างเป็นระบบและมีทิศทางเดียวกัน แนวคิดที่นิยมอย่าง Agile เน้นความยืดหยุ่น การปรับตัวตามสถานการณ์ และการทำงานเป็นรอบสั้นๆ (Sprint) เพื่อส่งมอบงานที่มีคุณค่าให้ผู้ใช้ได้เร็วที่สุด การเข้าใจกระบวนการเหล่านี้ไม่เพียงแต่ช่วยให้เราวางแผนงานได้ดีขึ้น แต่ยังช่วยให้การสื่อสารและการทำงานร่วมกับเพื่อนร่วมทีมในตำแหน่งอื่นๆ เช่น Product Manager หรือ Designer เป็นไปอย่างราบรื่น",
                        tasks: [
                            { title: "เข้าใจแนวคิดหลักของ Agile", description: "Agile ไม่ใช่กฎตายตัว แต่เป็นชุดของหลักการและค่านิยมที่เน้นความสำคัญของการพัฒนาซ้ำๆ เป็นรอบสั้นๆ, การทำงานร่วมกันอย่างใกล้ชิดระหว่างทีมพัฒนาและฝั่งธุรกิจ, และการตอบสนองต่อการเปลี่ยนแปลงมากกว่าการทำตามแผนที่วางไว้แต่แรกอย่างเคร่งครัด หัวใจของมันคือการสร้างซอฟต์แวร์ที่ตอบโจทย์ผู้ใช้ได้จริงและส่งมอบได้อย่างรวดเร็ว" },
                            { title: "รู้จักพิธีกรรม (Ceremonies) ของ Scrum", description: "Scrum คือ Framework ที่ได้รับความนิยมที่สุดในการนำ Agile มาปฏิบัติจริง มันกำหนด 'พิธีกรรม' หรือการประชุมที่ชัดเจนเพื่อช่วยให้ทีมทำงานได้อย่างเป็นระบบ เช่น Daily Stand-up เพื่ออัปเดตความคืบหน้าทุกวัน, Sprint Planning เพื่อวางแผนงานในรอบถัดไป, และ Sprint Retrospective เพื่อทบทวนและปรับปรุงการทำงานของทีม การเข้าใจวัตถุประสงค์ของแต่ละพิธีกรรมจะช่วยให้คุณมีส่วนร่วมในการทำงานของทีมได้อย่างเต็มที่" },
                            { title: "ลองใช้เครื่องมือจัดการโปรเจกต์ (เช่น Trello, Jira) ในรูปแบบ Kanban Board", description: "Kanban Board เป็นเครื่องมือที่ช่วยให้เห็นภาพกระบวนการทำงานทั้งหมดได้อย่างชัดเจน โดยจะแบ่งงานออกเป็นการ์ดและมีคอลัมน์แทนสถานะของงาน (เช่น To Do, In Progress, Done) มันช่วยให้ทีมสามารถติดตามความคืบหน้า, ระบุปัญหาคอขวด, และจัดการลำดับความสำคัญของงานได้ง่ายขึ้น การได้ลองใช้เครื่องมือเหล่านี้กับโปรเจกต์ส่วนตัวจะทำให้คุณคุ้นเคยกับวิธีการทำงานที่เป็นมาตรฐานในบริษัทส่วนใหญ่" }
                        ]
                    },
                    {
                        title: "14. Programming Language & Tooling (ภาษาและเครื่องมือ)",
                        detailedIntro: "ภาษาโปรแกรมและเครื่องมือคืออาวุธคู่กายของ Software Engineer การเชี่ยวชาญภาษาโปรแกรมอย่างน้อยหนึ่งภาษาอย่างลึกซึ้ง ไม่ใช่แค่เขียนได้ แต่ต้องเข้าใจปรัชญาและจุดแข็งของภาษานั้นๆ จะทำให้เราแก้ปัญหาได้อย่างถูกวิธี นอกจากนี้ การใช้เครื่องมือต่างๆ เช่น IDE/Editor, Debugger, และ Command Line ได้อย่างคล่องแคล่ว จะช่วยเพิ่มความเร็วและประสิทธิภาพในการทำงานได้อย่างมหาศาล เปรียบเสมือนช่างฝีมือที่รู้จักและใช้เครื่องมือของตัวเองได้อย่างเต็มประสิทธิภาพ",
                        tasks: [
                            { title: "เลือกภาษาโปรแกรมหลัก 1 ภาษาและศึกษาให้ลึกซึ้ง", description: "การเป็น 'Jack of all trades, master of none' อาจไม่เพียงพอในโลกปัจจุบัน การเลือกภาษาโปรแกรมที่คุณสนใจหรือเป็นที่ต้องการของตลาด (เช่น Python, JavaScript, Go) แล้วศึกษาลงไปให้ลึกซึ้งถึงแนวคิดเบื้องหลัง, Ecosystem, และ Best Practice ของภาษานั้นๆ จะทำให้คุณเป็นผู้เชี่ยวชาญที่สามารถแก้ปัญหาที่ซับซ้อนได้ และความเข้าใจในระดับลึกนี้ยังสามารถนำไปปรับใช้กับการเรียนรู้ภาษาอื่นๆ ในอนาคตได้ง่ายขึ้น" },
                            { title: "ใช้เครื่องมือ Debugger ใน IDE/Editor ของตัวเองได้อย่างมีประสิทธิภาพ", description: "Debugger คือเพื่อนที่ดีที่สุดของนักพัฒนา มันคือเครื่องมือที่ช่วยให้เราสามารถหยุดการทำงานของโปรแกรมไว้ชั่วคราว แล้วเข้าไปสำรวจค่าของตัวแปรต่างๆ และดูการทำงานทีละบรรทัดได้ การใช้ Debugger อย่างคล่องแคล่วจะช่วยให้คุณสามารถหาต้นตอของบั๊กที่ซับซ้อนได้อย่างรวดเร็วและแม่นยำ ซึ่งมีประสิทธิภาพกว่าการใช้ `console.log` หรือ `print` อย่างเทียบไม่ติด" },
                            { title: "ใช้ Command Line พื้นฐาน (cd, ls, grep, mkdir) ได้อย่างคล่องแคล่ว", description: "ถึงแม้เราจะมีโปรแกรมที่มีหน้าตาสวยงาม (GUI) มากมาย แต่ Command Line หรือ Terminal ยังคงเป็นเครื่องมือที่ทรงพลังและขาดไม่ได้สำหรับนักพัฒนา มันให้ความเร็วและความยืดหยุ่นในการทำงานกับไฟล์, การรันโปรแกรม, การใช้งาน Git, และการเชื่อมต่อกับเซิร์ฟเวอร์ การใช้คำสั่งพื้นฐานได้อย่างคล่องแคล่วโดยไม่ต้องพึ่งพา GUI ตลอดเวลา จะช่วยเพิ่มประสิทธิภาพในการทำงานของคุณได้อย่างมาก" }
                        ]
                    },
                    {
                        title: "15. Soft Skills (ทักษะด้านบุคคล)",
                        detailedIntro: "ทักษะทางเทคนิคจะไร้ความหมายหากขาดทักษะด้านบุคคล หรือ Soft Skills การสื่อสารที่มีประสิทธิภาพช่วยให้เราสามารถอธิบายเรื่องซับซ้อนให้คนอื่นเข้าใจและทำงานร่วมกันได้อย่างราบรื่น การทำงานเป็นทีม การให้และรับฟังความคิดเห็นอย่างสร้างสรรค์ และการแก้ปัญหาอย่างเป็นระบบ ล้วนเป็นสิ่งที่แยกนักพัฒนาที่ดีออกจากนักพัฒนาที่ยอดเยี่ยม และที่สำคัญที่สุดคือความสามารถในการเรียนรู้สิ่งใหม่ๆ อยู่เสมอ เพราะเทคโนโลยีในวงการนี้เปลี่ยนแปลงเร็วมาก",
                        tasks: [
                            { title: "ฝึกเขียนเอกสาร (README.md) อธิบายโปรเจกต์ให้คนอื่นเข้าใจง่าย", description: "โค้ดที่ดีควรมาพร้อมกับเอกสารที่ดี ไฟล์ README.md คือหน้าตาของโปรเจกต์คุณ มันควรจะอธิบายได้ว่าโปรเจกต์นี้คืออะไร, มีฟีเจอร์อะไรบ้าง, และคนอื่นจะติดตั้งและใช้งานมันได้อย่างไร การฝึกเขียนเอกสารที่ชัดเจนและกระชับจะช่วยให้เพื่อนร่วมทีมในอนาคต (หรือแม้แต่ตัวคุณเอง) สามารถเข้ามาทำความเข้าใจโปรเจกต์ได้อย่างรวดเร็ว และยังแสดงถึงความเป็นมืออาชีพของคุณอีกด้วย" },
                            { title: "ขอให้เพื่อนช่วยทำ Code Review และเปิดใจรับฟังความคิดเห็น", description: "Code Review คือกระบวนการที่สำคัญอย่างยิ่งในการพัฒนาคุณภาพซอฟต์แวร์ มันคือการที่เพื่อนร่วมทีมช่วยกันตรวจสอบโค้ดเพื่อหาจุดที่อาจเกิดข้อผิดพลาด, จุดที่สามารถเขียนให้ดีขึ้นได้, หรือจุดที่ไม่เป็นไปตามมาตรฐานของทีม การเปิดใจรับฟังความคิดเห็นอย่างสร้างสรรค์และไม่มองว่าเป็นเรื่องส่วนตัว คือทัศนคติที่สำคัญในการเติบโตในฐานะนักพัฒนา และยังเป็นโอกาสที่ดีในการเรียนรู้มุมมองใหม่ๆ จากผู้อื่น" },
                            { title: "ฝึกอธิบายเรื่องทางเทคนิคที่ซับซ้อนให้คนที่ไม่ใช่สายเทคนิคเข้าใจ", description: "ในโลกการทำงานจริง เราต้องสื่อสารกับคนที่ไม่ใช่โปรแกรมเมอร์อยู่เสมอ เช่น Product Manager, Designer, หรือแม้แต่ลูกค้า การสามารถอธิบายแนวคิดทางเทคนิคที่ซับซ้อนโดยใช้คำพูดธรรมดาและยกตัวอย่างเปรียบเทียบให้คนทั่วไปเข้าใจได้ เป็นทักษะการสื่อสารที่มีค่าอย่างยิ่ง มันช่วยลดความเข้าใจผิดและทำให้ทุกคนในทีมมองเห็นภาพเดียวกัน ซึ่งนำไปสู่การทำงานที่ราบรื่นขึ้น" },
                            { title: "ตั้งเป้าหมายและลงมือเรียนรู้เทคโนโลยีใหม่ๆ ด้วยตัวเองอย่างสม่ำเสมอ", description: "ทักษะที่สำคัญที่สุดที่แท้จริงของ Software Engineer คือ 'ความสามารถในการเรียนรู้' (Learnability) วงการเทคโนโลยีเปลี่ยนแปลงเร็วมาก สิ่งที่ทันสมัยในวันนี้อาจจะล้าหลังในอีกไม่กี่ปีข้างหน้า การสร้างนิสัยในการติดตามข่าวสาร, อ่านบทความ, ลองเล่นเทคโนโลยีใหม่ๆ, และสามารถเรียนรู้ได้ด้วยตัวเองอย่างต่อเนื่อง คือสิ่งที่รับประกันว่าคุณจะยังคงเป็นที่ต้องการและสามารถเติบโตในสายอาชีพนี้ได้ในระยะยาว" }
                        ]
                    }
                ]
            }
        ];

        function renderSkillGroups() {
            const container = document.getElementById('skill-groups-container');
            container.innerHTML = '';
            skillData.forEach((group) => {
                const groupElement = document.createElement('div');
                groupElement.className = 'card rounded-2xl shadow-lg';
                
                const subgroupsHtml = group.subgroups.map((subgroup) => {
                    const tasksHtml = subgroup.tasks.map(task => {
                        return `
                            <div class="border-t border-slate-200/80">
                                <button class="accordion-button w-full flex justify-between items-center p-4 pl-12 text-left text-slate-800 hover:bg-slate-100/70 transition-colors duration-200">
                                    <span class="font-semibold">${task.title}</span>
                                    <svg class="w-5 h-5 text-slate-400 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                                </button>
                                <div class="accordion-content">
                                    <div class="px-6 pb-5 pl-16 pt-2">
                                        <p class="text-slate-600 text-sm leading-relaxed">${task.description}</p>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');

                    return `
                        <div class="border-b border-slate-200/80 last:border-b-0">
                            <button class="accordion-button w-full flex justify-between items-center p-6 text-left hover:bg-slate-100/50 transition-colors duration-200">
                                <span class="text-lg font-medium text-slate-900">${subgroup.title}</span>
                                <svg class="w-6 h-6 text-slate-500 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                            </button>
                            <div class="accordion-content">
                                <div class="accordion-content-inner px-6 pb-4 pt-4">
                                    <div class="text-slate-600 leading-relaxed mb-6 border-l-4 border-slate-300 pl-4">
                                        <p>${subgroup.detailedIntro}</p>
                                    </div>
                                    <div class="space-y-1 bg-slate-50/80 rounded-lg border border-slate-200/80">
                                        ${tasksHtml}
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');

                groupElement.innerHTML = `
                    <button class="accordion-button w-full flex justify-between items-center p-6 text-left transition-colors duration-200">
                        <div class="pr-4">
                            <h2 class="text-2xl font-semibold text-slate-900 mb-2">${group.group}</h2>
                            <p class="text-slate-600 text-left">${group.intro}</p>
                        </div>
                        <svg class="w-8 h-8 text-slate-400 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    <div class="accordion-content" style="max-height: 75vh; overflow-y: auto;">
                        <div class="accordion-content-inner border-t border-slate-200/80">
                            ${subgroupsHtml}
                        </div>
                    </div>
                `;
                container.appendChild(groupElement);
            });
        }
        
        function addEventListeners() {
            document.querySelectorAll('.accordion-button').forEach(button => {
                button.addEventListener('click', (event) => {
                    event.stopPropagation(); 
                    
                    const content = button.nextElementSibling;
                    const wasOpen = button.classList.contains('open');
                    
                    button.classList.toggle('open');
                    
                    if (wasOpen) {
                        content.style.maxHeight = null;
                    } else {
                        // For nested accordions, we don't set a fixed scroll height
                        // but for the top-level one, we do.
                        if (content.parentElement.classList.contains('card')) {
                             content.style.maxHeight = '75vh';
                        } else {
                             content.style.maxHeight = content.scrollHeight + "px";
                        }
                    }

                    // Adjust parent accordions' heights if they are not the main scrollable container
                    let parent = button.parentElement.closest('.accordion-content');
                    if(parent && !parent.style.overflowY) {
                         if(parent.style.maxHeight !== '0px' && parent.style.maxHeight) {
                           parent.style.maxHeight = parent.scrollHeight + content.scrollHeight + "px";
                        }
                    }
                });
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            renderSkillGroups();
            addEventListeners();
        });
    </script>
</body>
</html>
